# 설명

<pre><code>기준 색상 3개 3차원 색공간에 배치

k는 클러스터링의 군집수

k=1 일떄

중심 색상 1개 추출  →  기준 색상 과의 각 거리 계산 
결과 : 3개의 결과 중 가장 짧은 거리와 가장 짧은 거리를 가진 색상의 쌍 (중심색상 - 기준 색상) 저장 
# 기준 색상만 사전에 저장해도 됨

k=2 일떄

중심 색상 2개 추출  →  기준 색상 과의 각 거리 계산 후 사전에 넣음
결과 : 6개의 결과 중 가장 짧은 거리와 가장 짧은 거리를 가진 색상의 쌍 (중심색상 - 기준 색상) 저장 
# 기준 색상만 사전에 저장해도 됨

...

k=n 일떄

중심 색상 n개 추출  →  기준 색상 과의 각 거리 계산 후 사전에 넣음
결과 : n x 3개의 결과 중 가장 짧은 거리와 가장 짧은 거리를 가진 색상의 쌍 (중심색상 - 기준 색상) 저장 
# 기준 색상만 사전에 저장해도 됨

사전 내에서 가장 짧은 거리쌍을 찾음 : 결과는 기준 색상을 출력하면 됨</code></pre>

<br>

# 스케치 코드 (숫자는 예시)

<pre><code>기준 색상 색공간에 배치 (전역 변수로 3개의 RGB 색상을 정의만 하면 됨)
A색 = [1,2,3]
B색 = [4,5,6]
C색 = [7,8,9]
기준 색상 = [A색, B색, C색]

전체_딕셔너리 = {}  
# 전체_딕셔너리 = {k=1일 떄 최단거리를 가진 기준 색상 : 최단 거리, k=2일 떄 최단거리를 가진 기준 색상 : 최단 거리, k=n일 떄 최단거리를 가진 기준 색상 : 최단 거리}

거리 계산 함수(a,b)
    유클리드 거리 계산 # 다른 계산 방식을 사용해도 됩니다. ex) 맨해튼 거리


클러스터링 비교 함수(k)
    클러스터링이 추출한 색상_1 = [10,11,12]
    클러스터링이 추출한 색상_2 = [13,14,15]
    ...
    클러스터링이 추출한 색상_k = [16,17,18]
    
    리스트 = [클러스터링이 추출한 색상_1, 클러스터링이 추출한 색상_2, ... ,클러스터링이 추출한 색상_k] 
    # 리스트 선언후 append()같은 메서드를 사용하면 편합니다.
    
    클러스터링_딕셔너리 = {}
    for x in 리스트
            for y in 기준 색상
            기준 색상 = y
            거리 = 거리 계산 함수(x, y)
            클러스터링_딕셔너리[기준 색상] = 거리 # 딕셔너리에 단순히 추가하면 됩니다.
            딕셔너리에서 가장 짧은 거리와 기준 색상 추출 or 비교 알고리즘 실행 (되도록 시간 복잡도가 작은 걸로..)

return 최단 거리 와 기준 색상 # 기준 색상은 별도의 변수에 추가해도 됩니다.


main()
    for k in range(n)
        가장 짧은 거리 = 클러스터링 비교 함수(k)
        가장 짧은 거리를 가진 기준 색상 = 클러스터링 비교 함수(k)

        전체_딕셔너리[가장 짧은 거리를 가진 기준 색상] = 가장 짧은 거리
  
전체_딕셔너리 중 가장 짧은 거리를 가진 기준 색상을 추출</code></pre>
